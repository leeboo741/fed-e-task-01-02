# JS 性能优化
```js
    // 本阶段核心是 js 语言的优化
```
## 内存管理

```js
    内存管理介绍
    内存: 由可读写单元组成, 标识一片可操作控件
    管理: 人为的去操作一片控件的申请, 使用和释放
    内存管理: 开发者主动申请, 使用, 释放 空间
    管理流程: 申请 -- 使用 -- 释放
```

```js
    // js 中的 内存管理
    // 申请空间
    
    // 使用空间

    // 释放空间
```

## 垃圾回收 与 常见GC算法

### js 中的垃圾回收

```js
    // js 中的垃圾
    // js 中内存管理是自动的
    // 对象不再被引用时是垃圾
    // 对象不能从跟上访问到时是垃圾

    // 可达对象 就是可以访问的对象 (引用, 作用域链);
    // 可达标准就是从根出发是否能够被找到
    // js 中的 根 可以理解为是全局变量对象, 全局执行上下文
```

```js
    // js 中的引用与可达
```

### GC算法

```js
    // GC定义
    // GC 就是 垃圾回收机制的间歇
    // GC 可以找到内存中的垃圾, 并释放和回收控件
```

```js
    // 1. 程序中不再需要使用的对象
    function func() {
        name = 'name';
        return `${name} is a coder`;
    }
    func();
    // 2. 程序中不能再访问到的对象

    function func2 () {
        const name = `name`;
        return `${name} is a coder`;
    }
    func2();
```

```js
    // 1. GC 是一种机制, 垃圾回收器完成具体的工作
    // 2. 工作内容就是查找垃圾, 释放空间, 回收空间
    // 3. 算法就是工作室查找和回收所遵循的规则
```

```js
    // 常用 GC 算法
    // 1. 引用计数
    // 2. 标记清除
    // 3. 标记整理
    // 4. 分代回收
```

#### 引用计数算法

```js
    // 核心思想: 设置引用数, 判断当前引用数是否为0, 当数值为0时 进行回收
    // 引用计数器
    // 当引用对象改变时 修改引用数字
    // 引用数字为0 立即回收
```

```js
    // 引用计数算法优点
    // 1. 发现垃圾时立即回收
    // 2. 最大限度减少程序暂停

    // 引用计数算法缺点
    // 1. 无法回收循环引用的对象
    // 2. 时间开销大
```

#### 标记清除算法

```js
    // 核心思想: 分标记 和 清除 两个阶段完成
    // 遍历所有对象并标记活动对象
    // 遍历所有对象清除没有标记对象
    // 回收相应的空间
```
```js
    // 优点
    // 1. 解决循环引用对象的释放问题

    // 缺点
    // 1. 空间的碎片化, 回收的空间在地址上是不连续的
```

#### 标记整理算法

```js
    // 标记整理可以看做标记清除的增强
    // 标记阶段的操作和标记清除一致
    // 清除阶段会先执行整理, 移动对象位置
```


## V8引擎的垃圾回收

```js
    // V8 是一款主流的 js 执行引擎
    // V8 采用即时编译, 速度很快
    // V8 内存设有上限 64位-->1.5G 32位-->800M
```
### V8 垃圾回收策略

```js
    // 采用 分代 回收的思想
    // 内存分为 新生代, 老生代
    // 针对不同对象采用不同算法
```

```js
    // 常用 GC 算法
    // 1. 分代回收
    // 2. 空间复制
    // 3. 标记清除
    // 4, 标记清理
    // 5. 标记增量
```

### V8 如何回收新/老生代对象

```js
    // v8 内存分配
    // 1. 内部空间 一分为二
    // 2. 小空间用于存储新生代对象(32M | 16M)
    // 3. 新生代指的是存活时间较短的对象
```

```js 
    // 新生代对象回收实现
    // 1. 回收过程采用复制算法 + 标记整理
    // 2. 新生代内存区 分为两个 等大小空间
    // 3. 使用空间为 from 空间, 空闲空间为 to 空间
    // 4. 将活动对象存储于 from 空间
    // 5. 对from空间进行标记整理后将活动对象拷贝至 to 空间
    // 6. 释放from空间
    // 7. from空间成为to空间, to空间成为from空间, 完成回收
```

```js
    // 回收细节说明
    // 拷贝过程中可能出现晋升
    // 晋升就是讲新生代对象移动至老生代
    // 一轮GC还存活的对象 需要晋升
    // To 空间的使用率超过25%, 需要将这一轮的活动对象移动至老年代中存储
```

``` js
    // 老生代对象实现回收
    // 老年代对象存放在右侧老生代区域
    // 64=>1.4G 32=>700M
    // 老年代对象就是指存活时间教程对象

    // 主要采用 标记清除/标记整理/增量标记算法
    // 首先使用标记清除完成垃圾空间的回收
    // 采用标记整理进行空间优化 (当发现晋升操作时, 如果老生代空间不足, 启动标记整理进行空间优化)
    // 采用增量标记进行效率优化
```

``` js
    // 新生代和老生代 细节对比
    // 新生代区域垃圾回收使用 空间换时间
    // 老生代区域垃圾回收不适合复制算法, 消耗空间过大, 不太划算
```

```js
    // 增量标记
    // 
```

## Performance 工具

```js
    // 为什么使用 Performance 
    // 1. GC 的目的是为了实现内存空间的良性循环
    // 2. 良心循环的基石是合理使用
    // 3. 时刻关注才能确定是否合理
    // 4. Performance 提供多种监控方式
```

```js
    //  通过 Performance 实时监控内存
    // 使用步骤
    // 1. 打开浏览器输入目标网址
    // 2. 进入开发人员工具面板, 选择性能
    // 3. 开启录制功能, 访问具体页面
    // 4. 执行用户行为, 一段时间后停止录制
    // 5. 分析界面中记录的内存信息
```

```js
    // 内存问题的体现

    // 内存问题的外在表现
    // 1. 页面出现延迟加载 或 经常性暂停 (可能有频繁的GC)
    // 2. 页面持续性出现糟糕的性能
    // 3. 页面的性能随时间延长越来越差

```

```js
    // 界定内存问题的标准
    // 1. 内存泄漏: 内存使用持续升高
    // 2. 内存膨胀: 在多数设备上都存在性能问题
    // 3. 频繁的GC: 通过内存变化图进行分析


    // 监控内存的几种方式
    // 1. 浏览器任务管理器
    // 2. Timeline 时序图记录
    // 3. 堆快照查找 分离 DOM
    // 4. 判断是否存在频繁的 GC
```

```js
    // 什么是分离 DOM
    // 界面元素存活在 DOM 树上 (节点还存在于树上, 显示中)
    // 垃圾对象时的 DOM 节点 (节点从DOM树上脱离, 没有人引用)
    // 分离状态的 DOM 节点 (节点从DOM树上脱离, 有人引用)
```

```js
    // 为什么确定频繁垃圾回收
    // 1. GC 工作时 应用程序是停止的
    // 2. 频繁且过长的GC 会导致应用假死
    // 3. 用户使用中会感知应用卡顿

    // 评判标准
    // 1. Timeline 中频繁的上升下降
    // 2. 任务管理器中数据频繁的增加减小
```

## 代码优化实例

```js
    // 如何精准测试 JS 性能

    // 本质上就是采集大量的执行样本进行数学统计和分析
    // 可以使用基于 Benchmark.js 的 https://jsperf.com/ 完成

    // jsperf 使用流程
    // 1. 使用 GitHub 登录
    // 2. 填写个人信息 (非必须)
    // 3. 填写详细的测试用例信息 (title, slug);
    // 4. 填写准备代码 (DOM 操作时经常使用);
    // 5. 填写必要的 setup (前置准备操作) 与 teardown (完成后收尾工作) 代码
    // 6. 填写测试代码片段
```

```js
    // 慎用全局变量

    // 为什么
    // 1. 全局变量定义在全局执行上下文, 是所有作用域链的顶端 (查找效率低, 都需要往上查找)
    // 2. 全局执行上下文一直存在于上下文执行栈, 知道程序退出 (降低程序运行过程中对内存的使用)
    // 3. 如果某个局部作用域出现了同名变量则会遮蔽或污染全局
```

```js
    // 缓存全局变量
    // 将使用中无法避免的全局变量缓存到局部
```

```js
    // 通过原型对象添加附加方法
    // 在原型对象上新增实例对象需要的方法

    var fn1 = function () {
        this.foo = function () {
            console.log(11111);
        }
    }
    let f1 = new fn1();

    var fn2 = function () {};
    fn2.prototype.foo = function () {
        console.log(11111);
    }
    let f2 = new fn2();

    f1.foo();
    f2.foo();

```

```js
    // 避开闭包陷阱

    // 闭包特点:
    // 1. 外部具有指向内部的引用
    // 2. 在 "外" 部作用域 访问 "内" 部作用域的数据
    function foo() {
        var name = 'lg';
        function fn() {
            console.log(name);
        }
        return fn;
    }
    var a = foo();
    a();

    // 关于闭包
    // 1. 闭包是一种强大的语法
    // 2. 闭包使用不当很容易出现内存泄漏
    // 3. 不要为了闭包而闭包

    function foo() {
        var el = documents.getElementsById('btn');
        el.onClick(function () {
            console.log(el.id);
        })
        el = null; // 取消引用, 避免内存泄露
    }
    foo();
```

```js
    // 避免属性访问方法的使用

    // js 中的面向对象 有点特别
    // 1. js 不需要属性的访问方法, 所有属性都是外部可见的
    // 2. 使用属性访问方法只会增加一层重定义, 没有访问的控制力
    function Person() {
        this.name = 'icoder';
        this.age = 18;
        this.getAge = function() {
            return this.age;
        }
    }
    const p1 = new Person();
    const a = p1.getAge();
    // ======================================= //
    function Person() {
        this.name = 'icoder';
        this.age = 18;
    }
    const p2 = new Person();
    const b = p2.age;
```

```js
    // for 循环 优化
    for (var i = 0; i < aBtns.length; i++) {
        console.log(i);
    }
    // ================================================= //
    for (var i = 0, len = aBtns.length; i < len ; i++) {
        console.log(i);
    }
```

```js
    // 采用最优的循环方式
    var arrayList = new Array(1,2,3,4,5,6,6,7);

    arrList.forEach(function(item) {
        console.log(item);
    })

    for (var i = 0, len = arrayList.length ; i < len; i++) {
        let item = arrayList[i];
        console.log(item);
    }

    for (var i in arrayList) {
        let item = arrayList[i];
        console.log(item);
    }
    // forin < for < forEach
```

```js
    // 节点添加优化
    // 节点的添加操作必然会有回流和重绘, 会造成较大的开销
```
```js
    // 1. 文档碎片方式
    // 普通方式
    for(var i = 0; i < 10; i++) {
        var op = document.createElement('p');
        op.innerHTML = i;
        document.body.appendChild(op);
    }

    // 采用文档碎片的方式添加节点
    const fragEle = document.createDocumentFragment();
    for (var i = 0; i < 10 ; i++) {
        var op = document.createElement('p');
        op.innerHTML = i;
        fragEle.appendChild(op);
    }
    document.body.appendChild(fragEle);
```

```js
    // 2. 克隆方式优化节点
    // 如果DOM树种已经有 类似标签
    <p id='box1'>old</p>

    for(var i = 0; i < 3 ; i++) {
        var op = document.createElement('p');
        op.innerHTML = i;
        document.body.appendChild(op);
    }

    // ===============================================//
    var oldP = document.getElementById('box1');
    for (var i = 0; i < 3; i++) {
        var newP = oldP.cloneNode(false);
        newP.innerHTML = i;
        document.body.appendChild(newP);
    }
```

```js
    // 直接量替换 new Object 操作

    var a = [1,2,3]; // 更快
    // =========================== // 
    var a1 = new Array(3);
    a1[0] = 1;
    a1[1] = 2;
    a1[2] = 3;
```